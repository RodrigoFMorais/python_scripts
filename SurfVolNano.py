###############################################################################
#       Code to calculate the surface and volume area of a Nanoparticle       #
#       by Rodrigo Ferreira de Morais                                         #
#       Date: 23/06/2014                                                      #
###############################################################################

#!/usr/bin/python

import sys
import math
import copy

###################### Functions #############################################
def CalcDist(a,b,vectors):
    dist = math.sqrt((a[1]-b[1])**2 + (a[2]-b[2])**2 + (a[3]-b[3])**2)
    for i in range(0,2):
        for j in (1,-1):
                newb = copy.copy(b)
                newb[i+1] = newb[i+1]+j*vectors[i][i]
                temp = math.sqrt((a[1]-newb[1])**2 + (a[2]-newb[2])**2 + (a[3]-newb[3])**2)

                if temp < dist:
                        dist = temp

    return dist

def CalcArea(a,b,c):
    #------------------------------------------------------------------------#
    #          Area =   1/2 |u x v|,                                         #
    #          where:                                                        #
    #                 u = (xb-xa,yb-ya,zb-za)                                #
    #                 v = (xc-xa,yc-ya,zc-za)                                #
    #------------------------------------------------------------------------#

    x=(c[3]-a[3])*(b[2]-a[2])-(b[3]-a[3])*(c[2]-a[2])
    y=(b[3]-a[3])*(c[1]-a[1])-(b[1]-a[1])*(c[3]-a[3])
    z=(b[1]-a[1])*(c[2]-a[2])-(b[2]-a[2])*(c[1]-a[1])
    area = 0.5 * math.sqrt((x)**2 + (y)**2 + (z)**2)
    return area


def CfileSurface(linhas,coordN,Name):
    
    file=open("surface.car","w")
    File2=open("surface_" + Name + ".vesta","w")
    
    File2.write("#VESTA_FORMAT_VERSION 3.1.9\n")
    File2.write("MOLECULE\n")
    File2.write("TITLE\n")
    File2.write(" Figure Vesta generated by script\n")
    File2.write("GROUP\n")
    File2.write("1 1 P 1\n")
    File2.write("SYMOP\n")
    File2.write(" 0.000000  0.000000  0.000000  1  0  0   0  1  0   0  0  1   1\n")
    File2.write(" -1.0 -1.0 -1.0  0 0 0  0 0 0  0 0 0\n")
    File2.write("TRANM\n")
    File2.write(" 0.000000  0.000000  0.000000  1  0  0   0  1  0   0  0  1\n")
    File2.write("LTRANSL\n")
    File2.write(" -1\n")
    File2.write(" 0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n")
    File2.write("LORIENT\n")
    File2.write(" -1   0   0   0   0\n")
    File2.write(" 1.000000  0.000000  0.000000  1.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  1.000000  0.000000  0.000000  1.000000\n")
    File2.write("LMATRIX\n")
    File2.write(" 1.000000  0.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  1.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  1.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  0.000000  1.000000\n")
    File2.write(" 0.000000  0.000000  0.000000\n")
    File2.write("CELLP\n")
    File2.write("  1.000000   1.000000   1.000000  90.000000  90.000000  90.000000\n")
    File2.write("  0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n")
    File2.write("STRUC\n")
    
    for i in range(0,4):
        file.write(linhas[i])
    
    j=1
    for i in range(0,len(coordN)):
        if coordN[i][len(coordN[i])-1]<12:
            file.write(linhas[i+4])
            File2.write(str(j)+"  Pt   Pt"+str(j)+"              1.0000  "+str(float(linhas[i+4].split()[1]))+"  "+str(float(linhas[i+4].split()[2]))+"  "+str(float(linhas[i+4].split()[3]))+"  1        -\n")
            File2.write("                            0.000000   0.000000   0.000000  0.00\n")
            j=j+1
    
    File2.write("  0 0 0 0 0 0 0\n")
    File2.write("THERI 0\n")

    j=1
    for i in range(0,len(coordN)):
        if coordN[i][len(coordN[i])-1]<12:
            File2.write(str(j)+"   Pt"+str(j)+"              1.0000\n")
            j=j+1


    File2.write("  0 0 0\n")
    File2.write("SHAPE\n")
    File2.write("  0       0       0       0   0.000000  0   192   192   192   192\n")
    File2.write("BOUND\n")
    File2.write("       0        1         0        1         0        1\n")
    File2.write("  0   0   0   0  0\n")
    File2.write("SBOND\n")
    File2.write("  1    Pt    Pt    0.00000    2.85700  0  1  0  0  1  0.250  1.000 180 180 180\n")
    File2.write("  0 0 0 0\n")
    File2.write("SITET\n")

    j=1
    for i in range(0,len(coordN)):
        if coordN[i][len(coordN[i])-1]<12:
            File2.write(str(j)+"   Pt"+str(j)+"              1.3900 203 197 191 203 197 191 204  0\n")
            j=j+1


    File2.write("  0 0 0 0 0 0\n")
    File2.write("VECTR\n")
    File2.write(" 0 0 0 0 0\n")
    File2.write("VECTT\n")
    File2.write(" 0 0 0 0 0\n")
    File2.write("SPLAN\n")
    File2.write("  0   0   0   0\n")
    File2.write("LBLAT\n")
    File2.write(" -1\n")
    File2.write("LBLSP\n")
    File2.write(" -1\n")
    File2.write("DLATM\n")
    File2.write(" -1\n")
    File2.write("DLBND\n")
    File2.write(" -1\n")
    File2.write("DLPLY\n")
    File2.write(" -1\n")
    File2.write("PLN2D\n")
    File2.write("  0   0   0   0\n")
    File2.write("ATOMT\n")
    File2.write("  1         Pt  1.3900 203 197 191 203 197 191 204\n")
    File2.write("  2          O  0.7400 254   3   0 254   3   0 204\n")
    File2.write("  3          H  0.4600 255 204 204 255 204 204 204\n")
    File2.write("  0 0 0 0 0 0\n")
    File2.write("SCENE\n")
    File2.write("-0.500085 -0.810746 -0.304311  0.000000\n")
    File2.write(" 0.837048 -0.542620  0.070100  0.000000\n")
    File2.write("-0.221958 -0.219667  0.949990  0.000000\n")
    File2.write(" 0.000000  0.000000  0.000000  1.000000\n")
    File2.write("  0.000   0.000\n")
    File2.write("  0.000\n")
    File2.write("  1.569\n")
    File2.write("HBOND 0 2\n")
    File2.write(" \n")
    File2.write("STYLE\n")
    File2.write("DISPF 147551\n")
    File2.write("MODEL   0  1  0\n")
    File2.write("SURFS   0  1  1\n")
    File2.write("SECTS  96  1\n")
    File2.write("FORMS   0  1\n")
    File2.write("ATOMS   0  0  1\n")
    File2.write("BONDS   1\n")
    File2.write("POLYS   1\n")
    File2.write("VECTS 1.000000\n")
    File2.write("FORMP\n")
    File2.write("  1  1.0   0   0   0\n")
    File2.write("ATOMP\n")
    File2.write(" 24  24   0  50  2.0   0\n")
    File2.write("BONDP\n")
    File2.write("  1  16  0.250  1.000 180 180 180\n")
    File2.write("POLYP\n")
    File2.write(" 204 1  1.000 180 180 180\n")
    File2.write("ISURF\n")
    File2.write("  0   0   0   0\n")
    File2.write("TEX3P\n")
    File2.write("  1  0.00000E+00  1.00000E+00\n")
    File2.write("SECTP\n")
    File2.write("  1  0.00000E+00  1.00000E+00  0.00000E+00\n")
    File2.write("HKLPP\n")
    File2.write(" 192 1  1.000 255   0 255\n")
    File2.write("UCOLP\n")
    File2.write("   0   1  1.000   0   0   0\n")
    File2.write("COMPS 1\n")
    File2.write("LABEL 1    12  1.000 0\n")
    File2.write("PROJT 0  0.962\n")
    File2.write("BKGRC\n")
    File2.write(" 255 255 255\n")
    File2.write("DPTHQ 1 -0.5000  3.5000\n")
    File2.write("LIGHT0 1\n")
    File2.write(" 1.000000  0.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  1.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  1.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  0.000000  1.000000\n")
    File2.write(" 0.000000  0.000000 20.000000  0.000000\n")
    File2.write(" 0.000000  0.000000 -1.000000\n")
    File2.write("  26  26  26 255\n")
    File2.write(" 179 179 179 255\n")
    File2.write(" 255 255 255 255\n")
    File2.write("LIGHT1\n")
    File2.write(" 1.000000  0.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  1.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  1.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  0.000000  1.000000\n")
    File2.write(" 0.000000  0.000000 20.000000  0.000000\n")
    File2.write(" 0.000000  0.000000 -1.000000\n")
    File2.write("   0   0   0   0\n")
    File2.write("   0   0   0   0\n")
    File2.write("   0   0   0   0\n")
    File2.write("LIGHT2\n")
    File2.write(" 1.000000  0.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  1.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  1.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  0.000000  1.000000\n")
    File2.write(" 0.000000  0.000000 20.000000  0.000000\n")
    File2.write(" 0.000000  0.000000 -1.000000\n")
    File2.write("   0   0   0   0\n")
    File2.write("   0   0   0   0\n")
    File2.write("   0   0   0   0\n")
    File2.write("LIGHT3\n")
    File2.write(" 1.000000  0.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  1.000000  0.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  1.000000  0.000000\n")
    File2.write(" 0.000000  0.000000  0.000000  1.000000\n")
    File2.write(" 0.000000  0.000000 20.000000  0.000000\n")
    File2.write(" 0.000000  0.000000 -1.000000\n")
    File2.write("   0   0   0   0\n")
    File2.write("   0   0   0   0\n")
    File2.write("   0   0   0   0\n")
    File2.write("ATOMM\n")
    File2.write(" 204 204 204 255\n")
    File2.write("  25.600\n")
    File2.write("BONDM\n")
    File2.write(" 255 255 255 255\n")
    File2.write(" 128.000\n")
    File2.write("POLYM\n")
    File2.write(" 255 255 255 255\n")
    File2.write(" 128.000\n")
    File2.write("SURFM\n")
    File2.write("   0   0   0 255\n")
    File2.write(" 128.000\n")
    File2.write("FORMM\n")
    File2.write(" 255 255 255 255\n")
    File2.write(" 128.000\n")
    File2.write("HKLPM\n")
    File2.write(" 255 255 255 255\n")
    File2.write(" 128.000\n")

    file.write("end\n")
    file.write("end\n")
    
    file.close()
    File2.close()


def CalcVol(a,b,c,CM):

    #------------------------------------------------------------------------#
    #          Volume =   1/6 (h.|u x v|),                                   #
    #          where:                                                        #
    #                 obs.: tran = origin translated to the center of mass   #
    #                 u = (xbtran-xatran,ybtran-yatran,zbtran-zatran)        #
    #                 v = (xctran-xatran,yctran-yatran,zctran-zatran)        #
    #                 h = (xatran-xCMtran,yatran-yCMtran,zatran-zCMtran)     #
    #------------------------------------------------------------------------#
    #print "------"
    #print a
    #print b
    #print c
    #print "------"

    atran=[]
    btran=[]
    ctran=[]

    p=0.0
    t=0.0
    vol=0.0

    u=[]
    v=[]

    atran.append(a[1]-CM[0])
    atran.append(a[2]-CM[1])
    atran.append(a[3]-CM[2])

    # btran=u
    btran.append(b[1]-CM[0])
    btran.append(b[2]-CM[1])
    btran.append(b[3]-CM[2])

    # ctran=v
    ctran.append(c[1]-CM[0])
    ctran.append(c[2]-CM[1])
    ctran.append(c[3]-CM[2])
    
    u.append(btran[0]-atran[0])
    u.append(btran[1]-atran[1])
    u.append(btran[2]-atran[2])
    
    v.append(ctran[0]-atran[0])
    v.append(ctran[1]-atran[1])
    v.append(ctran[2]-atran[2])
    
    p = atran[0]*u[1]*v[2] + atran[1]*u[2]*v[0] + atran[2]*u[0]*v[1]
    
    t = atran[2]*u[1]*v[0] + atran[0]*u[2]*v[1] + atran[1]*u[0]*v[2]

    vol = (1.0/6.0)*(p-t) 
    
    if vol<0:
        vol=vol*-1

    return vol

#----------------------------------------------------------------------------

def findTriangPiramide(CSurf,b,c,lista,vect):
    #----------------------------------------------------------------------------------#
    #   Find the triangular piramide return 1 if yes or 0 if no                        #
    #     imput two points that are neighbors from your reference                      #
    #----------------------------------------------------------------------------------#

    valor=1
    dista=0.0
    distb=0.0
    
    for i in range(0,len(lista)-1):
        dista=CalcDist(CSurf[b],CSurf[lista[i]],vect)
        distb=CalcDist(CSurf[c],CSurf[lista[i]],vect)
        #print dista,distb,b,c,lista[i]
        if (dista<=3.0) and (distb<=3.0) and (lista[i] <> b) and (lista[i] <> c):
            valor=2
            break

    #print b,c,lista[i]
    #print lista, valor

    return valor

def findSquaPiramide(CSurf,b,c,lista,vect):
    
    val=1
    dista=0.0
    distb=0.0
    distc=0.0
    distd=0.0
    
    for i in range(0,len(lista)-1):
        dista=CalcDist(CSurf[b],CSurf[lista[i]],vect)
        distb=CalcDist(CSurf[c],CSurf[lista[i]],vect)
        if dista <=3.0 and distb >3.0 and lista[i] <> b and lista[i] <> c:
            for j in range(0,len(lista)-1):
                distc=CalcDist(CSurf[lista[i]],CSurf[lista[j]],vect)
                distd=CalcDist(CSurf[c],CSurf[lista[j]],vect)
                if distc <=3.0 and distd >3.0 and lista[j] <> b and lista[j] <> c and lista[j] <> lista[i]:
                    val=2
                    break
    
    return val



def findTriangCoordSurfNum(a,b,c):

    #----------------------------------------------------------------------------------#
    #   Ordenate the Coordination Surface Number                                       #
    #----------------------------------------------------------------------------------#

    temp=0
    val=0
    lista=[]
    lista.append(int(a))
    lista.append(int(b))
    lista.append(int(c))

    for j in (0,len(lista)-2):
        for i in (1,len(lista)-1):
            if lista[j]>lista[i]:
                temp=lista[j]
                lista[j]=lista[i]
                lista[i] = temp
    
    val=str(lista[0])+str(lista[1])+str(lista[2])
    
    return val

def findTriangPiramide2(CSurf,lista,vect):
    #----------------------------------------------------------------------------------#
    #   Find the triangular piramide return 1 if yes or 0 if no                        #
    #     imput the list of surface neighbors                                          #
    #----------------------------------------------------------------------------------#

    valor=1
    dista=0.0
    distb=0.0
    distc=0.0
    
    for i in range(0,len(lista)-3):
        for j in range(i,len(lista)-2):
            dista=CalcDist(CSurf[lista[i]],CSurf[lista[j]],vect)
            if (dista<=3.0):
                for k in range(j,len(lista)-1): 
                    distb=CalcDist(CSurf[lista[i]],CSurf[lista[k]],vect)
                    distc=CalcDist(CSurf[lista[j]],CSurf[lista[k]],vect)
                    if (distb<=3.0) and (distc<=3.0):
                        valor=2
                        break
    return valor



def square_piramides(coordN,coordC,CM,cor,vect):

    #----------------------------------------------------------------------------------#
    #   calculate the area and Volument for square_piramides nanoparticle shape        #
    #----------------------------------------------------------------------------------#

    Result=[]
    CSurf=[]
    InCnSurf=[]
    TSurfA=0.0
    TVol=0.0
    a=0.0
    temp1=0.0
    counter=0

    #Calculate average surface atom distance
    for i in range(0,len(coordN)):
      if len(coordN[i])-1<12:
        for j in range(1,len(coordN[i])-1):
          if len(coordN[coordN[i][j]])-1<12:
             dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][0]],vect)
             if dist<=cor:
                temp1=temp1+dist
                counter=counter+1

    # Creat a list with the coordination of all surface atoms
    for i in range(0,len(coordN)):
        if len(coordN[i])-1<12:
            CSurf.append(coordC[i])

    # Creat a list with neighbors atoms at the surface and its CN on the surface
    for i in range(0,len(CSurf)):
        temp=[]
        for j in range(0,len(CSurf)):
            if i<>j :
                dist=CalcDist(CSurf[i],CSurf[j],vect)
                if dist<=3.0:
                    temp.append(j)
        temp.append(len(temp))
        InCnSurf.append(temp)
    #teste=0
    # Creat surface mesh of triangles according to the rules fo the truncated octahedron
    for i in range(0,len(InCnSurf)):
            for j in range(0,len(InCnSurf[i])-2):
                for k in range(j+1,len(InCnSurf[i])-1):
                    dist=CalcDist(CSurf[InCnSurf[i][j]],CSurf[InCnSurf[i][k]],vect)
                    if dist<=3.0:
                        #opt=findTriangPiramide(CSurf,InCnSurf[i][k],InCnSurf[i][j],InCnSurf[i]) 
                        #if opt==1:
                        temp=[]
                        temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/3)
                        temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/3)
                        Result.append(temp)

                    elif dist<=4.0:
                        TCSN=findTriangCoordSurfNum(InCnSurf[i][len(InCnSurf[i])-1],InCnSurf[InCnSurf[i][j]][len(InCnSurf[InCnSurf[i][j]])-1],InCnSurf[InCnSurf[i][k]][len(InCnSurf[InCnSurf[i][k]])-1])
                        if (int(TCSN[2])<6):
	                    temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/2)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/2)
                            Result.append(temp)
                            
                                
    # total surface area and volume:
    for i in range(0,len(Result)):
        TSurfA=TSurfA+Result[i][0]
        TVol=TVol+Result[i][1]
    print TSurfA, TVol
    
    cor=temp1/counter
        
    a=math.sqrt(TSurfA/(1.0+math.sqrt(3)))

    TSurfAR=((1+math.sqrt(3))*(cor*(int(a/cor)+1))**2)
    
    TVolR=(math.sqrt(2)/6)*(cor*(int(a/cor)+1))**3

    TSurfA=((1+math.sqrt(3))*(a+cor)**2)
    
    TVol=(math.sqrt(2)/6)*(a+cor)**3
#    print a,cor#,a/(int(a/cor)+1),(int(a/cor)+1)

    temp=[]
    temp.append(TSurfA)
    temp.append(TVol)
    temp.append(temp1/counter)
 
    return temp
#----------------------------------------------------------------------------

def rhombicuboctahedron(coordN,coordC,CM,cor,vect):

    #--------------------------------------------------------------------------------------------------------#
    #   calculate the area and Volument for Almost regular Rhombicuboctahedron nanoparticle shape            #
    #--------------------------------------------------------------------------------------------------------#

    Result=[]
    CSurf=[]
    InCnSurf=[]
    TSurfA=0.0
    TVol=0.0
    temp1=0.0
    counter=0

    #Calculate average surface atom distance
    for i in range(0,len(coordN)):
      if len(coordN[i])-1<12:
        for j in range(1,len(coordN[i])-1):
          if len(coordN[coordN[i][j]])-1<12:
             dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][0]],vect)
             if dist<=cor:
                temp1=temp1+dist
                counter=counter+1

    # Creat a list with the coordination of all surface atoms
    for i in range(0,len(coordN)):
        if len(coordN[i])-1<12:
            CSurf.append(coordC[i])

    # Creat a list with neighbors atoms at the surface and its CN on the surface
    for i in range(0,len(CSurf)):
        temp=[]
        for j in range(0,len(CSurf)):
            if i<>j :
                dist=CalcDist(CSurf[i],CSurf[j],vect)
                if dist<=3.0:
                    temp.append(j)
        temp.append(len(temp))
        InCnSurf.append(temp)

    # Creat surface mesh of triangles according to the rules fo the truncated octahedron
    for i in range(0,len(InCnSurf)):
            for j in range(0,len(InCnSurf[i])-2):
                for k in range(j+1,len(InCnSurf[i])-1):
                    dist=CalcDist(CSurf[InCnSurf[i][j]],CSurf[InCnSurf[i][k]],vect)
                    if dist<=3.0:
                        TCSN=findTriangCoordSurfNum(InCnSurf[i][len(InCnSurf[i])-1],InCnSurf[InCnSurf[i][j]][len(InCnSurf[InCnSurf[i][j]])-1],InCnSurf[InCnSurf[i][k]][len(InCnSurf[InCnSurf[i][k]])-1])
                        
                        if (TCSN=='566'  and TCSN=='577' and TCSN=='51010'):
                            temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/3)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/3)
                            Result.append(temp)

                    elif dist<=4.0:
                        TCSN=findTriangCoordSurfNum(InCnSurf[i][len(InCnSurf[i])-1],InCnSurf[InCnSurf[i][j]][len(InCnSurf[InCnSurf[i][j]])-1],InCnSurf[InCnSurf[i][k]][len(InCnSurf[InCnSurf[i][k]])-1])
                        if (int(TCSN[2])<6):
	                    temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/2)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/2)
                            Result.append(temp)
                        elif (TCSN=='456'):
	                    temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/2)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/2)
                            Result.append(temp)
                                
    # total surface area and volume:
    for i in range(0,len(Result)):
        TSurfA=TSurfA+Result[i][0]
        TVol=TVol+Result[i][1]
    print TSurfA, TVol


    temp=[]
    temp.append(TSurfA)
    temp.append(TVol)
    temp.append(temp1/counter)
    
    return temp
#----------------------------------------------------------------------------



def truncated_cuboctahedron(coordN,coordC,CM,cor,vect):

    #-----------------------------------------------------------------------------------------#
    #   calculate the area and Volument for truncated cuboctahedron nanoparticle shape        #
    #-----------------------------------------------------------------------------------------#

    Result=[]
    CSurf=[]
    InCnSurf=[]
    TSurfA=0.0
    TVol=0.0
    temp1=0.0
    counter=0

    #Calculate average surface atom distance
    for i in range(0,len(coordN)):
      if len(coordN[i])-1<12:
        for j in range(1,len(coordN[i])-1):
          if len(coordN[coordN[i][j]])-1<12:
             dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][0]],vect)
             if dist<=cor:
                temp1=temp1+dist
                counter=counter+1

    # Creat a list with the coordination of all surface atoms
    for i in range(0,len(coordN)):
        if len(coordN[i])-1<12:
            CSurf.append(coordC[i])

    # Creat a list with neighbors atoms at the surface and its CN on the surface
    for i in range(0,len(CSurf)):
        temp=[]
        for j in range(0,len(CSurf)):
            if i<>j :
                dist=CalcDist(CSurf[i],CSurf[j],vect)
                if dist<=3.0:
                    temp.append(j)
        temp.append(len(temp))
        InCnSurf.append(temp)

    # Creat surface mesh of triangles according to the rules fo the truncated octahedron
    for i in range(0,len(InCnSurf)):
            for j in range(0,len(InCnSurf[i])-2):
                for k in range(j+1,len(InCnSurf[i])-1):
                    dist=CalcDist(CSurf[InCnSurf[i][j]],CSurf[InCnSurf[i][k]],vect)
                    if dist<=3.0:
                        temp=[]
                        temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/3)
                        temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/3)
                        Result.append(temp)

                    elif dist<=4.0:
                        TCSN=findTriangCoordSurfNum(InCnSurf[i][len(InCnSurf[i])-1],InCnSurf[InCnSurf[i][j]][len(InCnSurf[InCnSurf[i][j]])-1],InCnSurf[InCnSurf[i][k]][len(InCnSurf[InCnSurf[i][k]])-1])
                        if (int(TCSN[2])<6):
	                    temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/2)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/2)
                            Result.append(temp)
                            
                                
    # total surface area and volume:
    for i in range(0,len(Result)):
        TSurfA=TSurfA+Result[i][0]
        TVol=TVol+Result[i][1]
#    print TSurfA, TVol

    cor=temp1/counter

    #a=math.sqrt(TSurfA/(2*math.sqrt(3)))
    # Tenho que verificar, formula esta incorreta 
    #TSurfA=((2*math.sqrt(3))*(a+cor)**2)
     
    #TVol=((1.0/3.0)*math.sqrt(2))*(a+cor)**3
        
    temp=[]
    temp.append(TSurfA)
    temp.append(TVol)
    temp.append(temp1/counter)
    
    return temp
#----------------------------------------------------------------------------

def truncated_tetrahedron(coordN,coordC,CM,cor,vect):

    #----------------------------------------------------------------------------------#
    #   calculate the area and Volument for truncated_tetrahedron nanoparticle shape   #
    #----------------------------------------------------------------------------------#

    Result=[]
    CSurf=[]
    InCnSurf=[]
    TSurfA=0.0
    TVol=0.0
    a=0.0
    temp1=0.0
    counter=0

    #Calculate average surface atom distance
    for i in range(0,len(coordN)):
      if len(coordN[i])-1<12:
        for j in range(1,len(coordN[i])-1):
          if len(coordN[coordN[i][j]])-1<12:
             dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][0]],vect)
             if dist<=cor:
                temp1=temp1+dist
                counter=counter+1

    # Creat a list with the coordination of all surface atoms
    for i in range(0,len(coordN)):
        if len(coordN[i])-1<12:
            CSurf.append(coordC[i])

    # Creat a list with neighbors atoms at the surface and its CN on the surface
    for i in range(0,len(CSurf)):
        temp=[]
        for j in range(0,len(CSurf)):
            if i<>j :
                dist=CalcDist(CSurf[i],CSurf[j],vect)
                if dist<=3.0:
                    temp.append(j)
        temp.append(len(temp))
        InCnSurf.append(temp)

    # Creat surface mesh of triangles according to the rules fo the truncated octahedron
    for i in range(0,len(InCnSurf)):
            for j in range(0,len(InCnSurf[i])-2):
                for k in range(j+1,len(InCnSurf[i])-1):
                    dist=CalcDist(CSurf[InCnSurf[i][j]],CSurf[InCnSurf[i][k]],vect)
                    if dist<=3.0:
                        TCSN=findTriangCoordSurfNum(InCnSurf[i][len(InCnSurf[i])-1],InCnSurf[InCnSurf[i][j]][len(InCnSurf[InCnSurf[i][j]])-1],InCnSurf[InCnSurf[i][k]][len(InCnSurf[InCnSurf[i][k]])-1])
                        
                        if (TCSN=='666'  or TCSN=='566' or TCSN=='666' or TCSN=='555' or TCSN=='559' or TCSN=='556'):
                            opt=1
                        elif (TCSN=='577'):
                            opt=2
                        elif (TCSN=='567' or TCSN=='667' or TCSN=='677'):
                            opt=findTriangPiramide(CSurf,InCnSurf[i][k],InCnSurf[i][j],InCnSurf[i],vect) 
                        elif (TCSN=='999' or TCSN=='599'):
                            print "Desconcidering 599 or 999 TCSNs"
                            opt=0
                        else:
                            print "Error found new type of TCSN ",TCSN
                            break

                        if opt==1:
                            temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/3)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/3)
                            Result.append(temp)
                        elif opt==2:
                            temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/6)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/6)
                            Result.append(temp)
                            
    # total surface area and volume:
    for i in range(0,len(Result)):
        TSurfA=TSurfA+Result[i][0]
        TVol=TVol+Result[i][1]
    print TSurfA, TVol
    cor=temp1/counter
    
    a=math.sqrt(TSurfA/(7*math.sqrt(3)))

    TSurfA=((7*math.sqrt(3))*(a+cor)**2)
    
    TVol=((23/12)*math.sqrt(2))*(a+cor)**3
#    print a,cor#,a/(int(a/cor)+1)

    temp=[]
    temp.append(TSurfA)
    temp.append(TVol)
    temp.append(temp1/counter)
    
	
    return temp
#----------------------------------------------------------------------------


def truncated_octahedron(coordN,coordC,CM,cor,vect):

    #---------------------------------------------------------------------------------#
    #   calculate the area and Volument for truncated_octahedron nanoparticle shape   #
    #---------------------------------------------------------------------------------#

    Result=[]
    CSurf=[]
    InCnSurf=[]
    TSurfA=0.0
    TVol=0.0
    a=0.0
    temp1=0.0
    counter=0
 
     #Calculate average surface atom distance
    for i in range(0,len(coordN)):
       if len(coordN[i])-1<12:
         for j in range(1,len(coordN[i])-1):
           if len(coordN[coordN[i][j]])-1<12:
              dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][0]],vect)
              if dist<=cor:
                 temp1=temp1+dist
                 counter=counter+1

    # Creat a list with the coordination of all surface atoms
    for i in range(0,len(coordN)):
        if len(coordN[i])-1<12:
            CSurf.append(coordC[i])

    # Creat a list with neighbors atoms at the surface and its CN on the surface
    for i in range(0,len(CSurf)):
        temp=[]
        for j in range(0,len(CSurf)):
            if i<>j :
                dist=CalcDist(CSurf[i],CSurf[j],vect)
                if dist<=3.0:
                    temp.append(j)
        temp.append(len(temp))
        InCnSurf.append(temp)

    # Creat surface mesh of triangles according to the rules fo the truncated octahedron
    for i in range(0,len(InCnSurf)):
            for j in range(0,len(InCnSurf[i])-2):
                for k in range(j+1,len(InCnSurf[i])-1):
                    dist=CalcDist(CSurf[InCnSurf[i][j]],CSurf[InCnSurf[i][k]],vect)
                    if (InCnSurf[i][len(InCnSurf[i])-1] == 6) or ((InCnSurf[i][len(InCnSurf[i])-1] != 6) and (InCnSurf[InCnSurf[i][k]][len(InCnSurf[InCnSurf[i][k]])-1] == 6) and (InCnSurf[InCnSurf[i][j]][len(InCnSurf[InCnSurf[i][j]])-1] == 6)):
                        if dist<=3.0:
                            temp=[]
                            temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/3)
                            temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/3)
                            Result.append(temp)
                    else:
     			if dist<=4.0:
             			temp=[]
             			if dist<=3.0:
                                    temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/3)
                                    temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/3)
                      		else:
                                    temp.append(CalcArea(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]])/2)
                                    temp.append(CalcVol(CSurf[i],CSurf[InCnSurf[i][k]],CSurf[InCnSurf[i][j]],CM)/2)
                                Result.append(temp)
    
    # total surface area and volume:
    for i in range(0,len(Result)):
        TSurfA=TSurfA+Result[i][0]
        TVol=TVol+Result[i][1]
    print TSurfA, TVol
   
    cor=temp1/counter
 
    a=math.sqrt(TSurfA/(6+12*math.sqrt(3)))

    TSurfA=((6+12*math.sqrt(3))*(a+cor)**2)
    
    TVol=(8*math.sqrt(2))*(a+cor)**3
#    print a,cor#,a/(int(a/cor)+1)
        
    temp=[]
    temp.append(TSurfA)
    temp.append(TVol)
    temp.append(temp1/counter)
                         			
    return temp
#----------------------------------------------------------------------------

def cuboocthedron(coordN,coordC,CM,cor,vect):

    #------------------------------------------------------------------------#
    #   calculate the area and Volument for cuboctahedron nanoparticle shape #
    #------------------------------------------------------------------------#

    Result=[]
    TSurfA=0.0
    TVol=0.0
    a=0.0
    temp1=0.0
    counter=0

    #Calculate average surface atom distance
    for i in range(0,len(coordN)):
      if len(coordN[i])-1<12:
	for j in range(1,len(coordN[i])-1):
	  if len(coordN[coordN[i][j]])-1<12:
	     dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][0]],vect)
             if dist<=cor:
		temp1=temp1+dist
		counter=counter+1

    # Creat surface mesh of triangles
    for i in range(0,len(coordN)):
        if len(coordN[i])-1<12:
        
	   for j in range(1,len(coordN[i])-1):
		if len(coordN[coordN[i][j]])-1<12:
	     		for k in range(j+1,len(coordN[i])-1):
                		if len(coordN[coordN[i][k]])-1<12:	
					dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][k]],vect)
                			if dist<=4.0:
                         			temp=[]

                         			if dist<=3.0:
                                 			temp.append(CalcArea(coordC[coordN[i][0]],coordC[coordN[i][j]],coordC[coordN[i][k]])/3)
                                 			temp.append(CalcVol(coordC[coordN[i][0]],coordC[coordN[i][j]],coordC[coordN[i][k]],CM)/3)
                                 		else:
                                 			temp.append(CalcArea(coordC[coordN[i][0]],coordC[coordN[i][j]],coordC[coordN[i][k]])/2)
                                 			temp.append(CalcVol(coordC[coordN[i][0]],coordC[coordN[i][j]],coordC[coordN[i][k]],CM)/2)

                                                # surface triangule, area, vol
                         			Result.append(temp)
    # total surface area and volume:
    for i in range(0,len(Result)):
        TSurfA=TSurfA+Result[i][0]
        TVol=TVol+Result[i][1]
    print TSurfA, TVol
    
    cor=temp1/counter
    
    a=math.sqrt(TSurfA/(6+2*math.sqrt(3)))

    TSurfA=((6+2*math.sqrt(3))*(a+cor)**2)
    
    TVol=((5/3)*math.sqrt(2))*(a+cor)**3
    
    
#    print a,cor#,a/(int(a/cor)+1)

    temp=[]
    temp.append(TSurfA)
    temp.append(TVol)
    temp.append(temp1/counter)
                         			
    return temp
#----------------------------------------------------------------------------

def octahedron(coordN,coordC,CM,cor,vect):

    #------------------------------------------------------------------------#
    #   calculate the area and Volument for octahedron nanoparticle shape    #
    #------------------------------------------------------------------------#

    Result=[]
    TSurfA=0.0
    TVol=0.0
    a=0.0
    temp1=0.0
    counter=0

    #Calculate average surface atom distance
    for i in range(0,len(coordN)):
      if len(coordN[i])-1<12:
        for j in range(1,len(coordN[i])-1):
          if len(coordN[coordN[i][j]])-1<12:
             dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][0]],vect)
             if dist<=cor:
                temp1=temp1+dist
                counter=counter+1

 
    # Creat surface mesh of triangles
    for i in range(0,len(coordN)):
        if len(coordN[i])-1<12:
	   for j in range(1,len(coordN[i])-1):
		if len(coordN[coordN[i][j]])-1<12:
	     		for k in range(j+1,len(coordN[i])-1):
                		if len(coordN[coordN[i][k]])-1<12:
					dist=CalcDist(coordC[coordN[i][j]],coordC[coordN[i][k]],vect)
                			if dist<=3.0:
                         			temp=[]
                         			temp.append(CalcArea(coordC[coordN[i][0]],coordC[coordN[i][j]],coordC[coordN[i][k]])/3)
                         			temp.append(CalcVol(coordC[coordN[i][0]],coordC[coordN[i][j]],coordC[coordN[i][k]],CM)/3)
                         			Result.append(temp)


    # total surface area and volume:
    for i in range(0,len(Result)):
        TSurfA=TSurfA+Result[i][0]
        TVol=TVol+Result[i][1]
    print TSurfA, TVol
    
    cor=temp1/counter 
    
    a=math.sqrt(TSurfA/(2*math.sqrt(3)))

    TSurfA=((2*math.sqrt(3))*(a+cor)**2)

    TVol=((1.0/3.0)*math.sqrt(2))*(a+cor)**3

#    print a,cor#,a/(int(a/cor)+1)

    temp=[]
    temp.append(TSurfA)
    temp.append(TVol)
    temp.append(temp1/counter)
                            			
    return temp
#----------------------------------------------------------------------------


########################### Main code #######################################
coordC=[]
coordN=[]
CM=[]
SurfMeshT=[]
Nsurf=0
tempx=0.0
tempy=0.0
tempz=0.0
type=0
cor=2.77551 # Relaxed Pt-Pt distance
vect=[]

try:
   type=sys.argv[2]
except:
    print 'You should select the type of calculations'
    print ' c - cuboctahedron - (111) and (100) facets'
    print ' o - octahedron - just (111) facets '
    print ' to - truncated octahedron - (111) and (100) facets + rule for second neighbors with dist higher than the Pt-Pt bound'
    print ' tt - truncated tetrahedron - (111) + rule for neighbors that form piramides and 1/2piramides'
    print ' sq - square piramides - (111) and (100) + rule for neighbors that form piramides and 1/2piramides'
    sys.exit(2)

# ----------- Get xyz
file=open(sys.argv[1],"r")

linhas=file.readlines()

file.close()

#creat veact
temp=[]
temp.append(float(linhas[3].split()[1]))
temp.append(0.000)
temp.append(0.000)
vect.append(temp)
     
temp=[]
temp.append(0.000)
temp.append(float(linhas[3].split()[2]))
temp.append(0.000)
vect.append(temp)
 
temp=[]
temp.append(0.000)
temp.append(0.000)
temp.append(float(linhas[3].split()[3]))
vect.append(temp)
 
for i in range(4,len(linhas)-2):
    temp=[]
    temp.append(linhas[i].split()[0])
    temp.append(float(linhas[i].split()[1]))
    temp.append(float(linhas[i].split()[2]))
    temp.append(float(linhas[i].split()[3]))
    coordC.append(temp)

for i in range(0,len(coordC)):
    temp=[]
    temp.append(i)
    
    # CM center of the mass
    tempx = tempx + coordC[i][1]
    tempy = tempy + coordC[i][2]
    tempz = tempz + coordC[i][3]
    
    for j in range(0,len(coordC)):
        if i<>j :
            dist=CalcDist(coordC[i],coordC[j],vect)
            if dist<=3.3:
                temp.append(j)
                
    temp.append(len(temp)-1)
    if (len(temp)-1)<12:
        Nsurf = Nsurf + 1
    
    # selected atom, neighbors and coordination number
    coordN.append(temp)

# CM center of the mass
tempx = tempx / len(coordC)
tempy = tempy / len(coordC)
tempz = tempz / len(coordC)

CM.append(tempx)
CM.append(tempy)
CM.append(tempz)

# Creat VESTA file with just the surface atoms. Just to check!
CfileSurface(linhas,coordN,sys.argv[1][:-4])

# Calculate the area and the volume according to the geometry
if type=='c':
    Result=cuboocthedron(coordN,coordC,CM,cor,vect)
elif type=='o':
    Result=octahedron(coordN,coordC,CM,cor,vect)
elif type=='to':
    Result=truncated_octahedron(coordN,coordC,CM,cor,vect)
elif type=='tt':
    Result=truncated_tetrahedron(coordN,coordC,CM,cor,vect)
elif type=='sq':
    print "Working only for relaxed nanoparticle with square piramide morphology!"
    Result=square_piramides(coordN,coordC,CM,cor,vect)
elif type=='tc':
    print "Not a regurlar one, so no corrections applied!"
    Result=truncated_cuboctahedron(coordN,coordC,CM,cor,vect)
elif type=='r':
    print "Not a regurlar one, so no corrections applied!"
    Result=rhombicuboctahedron(coordN,coordC,CM,cor,vect)

print "##############################################################################"
print " "
print "Result for the relaxed nanoparticle : ", sys.argv[1][:-4]
print " "
print "The number of atoms at surface is :______________________ ", Nsurf
print "The center of mass is at :_______________________________ ", CM
print "The total surface area is :______________________________ ", Result[0], " Angs^2" #TSurfA
print "The total nanoparticle volume is :_______________________ ", Result[1], " Angs^3" #TVol
print "The The approximate size of the nanoparticle is :________ ", ((Result[1]/Result[0])*6)/10, " Nano"
print "The average surface atom distance is :___________________ ", Result[2], " Angs"
print " "
#print "-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -"
#print " "
#print "Result for the non-relaxed nanoparticle :"
##print " "
#print "The total surface area is :______________________________ ", Result[2], " Angs^2" #TSurfA
#print "The total nanoparticle volume is :_______________________ ", Result[3], " Angs^3" #TVol
##print "The The approximate size of the nanoparticle is :________ ", ((Result[3]/Result[2])*6)/10, " Nano"
#print " "
print "##############################################################################"
#----------------------------------------------------------------------------
